[
  {
    "path": "posts/httpsrpubscomspconway910890/",
    "title": "Data Import",
    "description": "importing data with R",
    "author": [
      {
        "name": "Sean Conway",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\nOverview\nToday, we’re going to read in three versions of the\npoultry_tidy data. All data files are available on the\nsample datasets page on the Google Classroom.\nWe will specifically read in 3 data files:\n- poultry_tidy.csv\n- poultry_tidy.xlsx\n- poultry_tidy.RData\nThese are the “clean” versions of the raw data files (which are also\navailable on Google Classroom).\nTo run this file, all 3 datasets should be in the same\ndirectory on your computer.\nGetting Started\nTo begin, we need to load two packages: readr and\nreadxl, which contain very useful functions for reading in\ndata to `R.\n\n\nlibrary(readr)\nlibrary(readxl)\n\n\n\nIf you’re unsure whether or not you have these packages installed,\nyou can run the following command:\n\n\ninstalled.packages()\n\n\n\nFirst, let’s check our working directory using the\ngetwd() command:\n\n\ngetwd()\n\n\n[1] \"/Users/seanconway/Teaching/DACSS_601_Su22/scripts\"\n\nI need to change my working directory to the location of the datasets\non my computer, using the setwd() command. Note that for\nRMarkdown files, the working directory will revert back to the file\nlocation for each code chunk. So we actually need to rerun this line\nbelow everytime we import data:\n\n\nsetwd(\"/Users/seanconway/Teaching/DACSS_601_Su22/data_cleaned\")\n\n\n\nWe’re now ready to get started reading in actual datasets.\nReading in delimited text\nfiles\n.csv is a common type of delimited text file.\n.csv stands for comma-separated value.\nThis means that commas separate cells from one another.\nR has a base read.csv() function. However,\nit comes with a couple of downsides - namely that it imports data as a\ndataframe rather than a tibble. So we will be using the function\nread_csv() from the readr package. In addition\nto importing data as a tibble, it also does a much better job guessing\ndata types.\nread_csv() is essentially a wrapper function (a function\nthat calls another function) around the more general\nread_delim() function. Also see read_tsv() for\ntab-separated values.\n\n\n?read_delim\n\n\n\nLet’s look at the data files available for us to read in:\n\n\nsetwd(\"/Users/seanconway/Teaching/DACSS_601_Su22/data_cleaned\")\nlist.files()\n\n\n [1] \"airforce_cleaned.csv\"               \n [2] \"army_cleaned.csv\"                   \n [3] \"australian_marriage_tidy.csv\"       \n [4] \"australian_marriage_tidy.RData\"     \n [5] \"australian_marriage_tidy.xlsx\"      \n [6] \"bicycle_NY_tidy.RData\"              \n [7] \"eggs_2004_2013.csv\"                 \n [8] \"eggs_tidy.xlsx\"                     \n [9] \"marinecorps_cleaned.csv\"            \n[10] \"marital_dod_tidy.RData\"             \n[11] \"marital_tidy_all.csv\"               \n[12] \"navy_cleaned.csv\"                   \n[13] \"poultry_tidy.csv\"                   \n[14] \"poultry_tidy.RData\"                 \n[15] \"poultry_tidy.xlsx\"                  \n[16] \"railroad_2012_clean_county_tidy.csv\"\n[17] \"railroad_2012_clean_county.xlsx\"    \n[18] \"railroad_2012_clean_state.csv\"      \n[19] \"railroad_2012_clean_state.xlsx\"     \n[20] \"railroad_2012_county.RData\"         \n[21] \"railroad_2012_state.RData\"          \n[22] \"starwars1.RData\"                    \n[23] \"test_objs.RData\"                    \n[24] \"totaldod_cleaned.csv\"               \n\nThere’s a lot of data files there, but we are going to import the\npoultry_tidy.csv file. Doing so is very simple using\nread_csv():\n\n\nsetwd(\"/Users/seanconway/Teaching/DACSS_601_Su22/data_cleaned\")\npoultry_from_csv <- read_csv(\"poultry_tidy.csv\")\n\n\n\nLet’s take a look at our dataset (to view the tibble, running the\nname of the object will print it to the console):\n\n\npoultry_from_csv\n\n\n# A tibble: 600 × 4\n   Product  Year Month     Price_Dollar\n   <chr>   <dbl> <chr>            <dbl>\n 1 Whole    2013 January           2.38\n 2 Whole    2013 February          2.38\n 3 Whole    2013 March             2.38\n 4 Whole    2013 April             2.38\n 5 Whole    2013 May               2.38\n 6 Whole    2013 June              2.38\n 7 Whole    2013 July              2.38\n 8 Whole    2013 August            2.38\n 9 Whole    2013 September         2.38\n10 Whole    2013 October           2.38\n# … with 590 more rows\n\nIt worked great! The data is all there. To inspect the data types for\neach of the four columns in poultry_from_csv, we can use\nspec() or typeof():\nNote: we can also avoid the setwd() issue by modifying\nthe name of the file to include the file path:\n\n\npoultry_from_csv <- read_csv(\"../data_cleaned/poultry_tidy.csv\")\n\n\n\n\n\nspec(poultry_from_csv) # use the spec() function to check the data type for your columns\n\n\ncols(\n  Product = col_character(),\n  Year = col_double(),\n  Month = col_character(),\n  Price_Dollar = col_double()\n)\n\n# can also use typeof() function on individual columns\ntypeof(poultry_from_csv$Product)\n\n\n[1] \"character\"\n\ntypeof(poultry_from_csv$Year)\n\n\n[1] \"double\"\n\ntypeof(poultry_from_csv$Month)\n\n\n[1] \"character\"\n\ntypeof(poultry_from_csv$Price_Dollar)\n\n\n[1] \"double\"\n\nSee this R section below for some more info on\nread_delim():\n\n\n# read_delim() has a number of optional arguments\nargs(read_delim)\n\n\nfunction (file, delim = NULL, quote = \"\\\"\", escape_backslash = FALSE, \n    escape_double = TRUE, col_names = TRUE, col_types = NULL, \n    col_select = NULL, id = NULL, locale = default_locale(), \n    na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, \n    skip = 0, n_max = Inf, guess_max = min(1000, n_max), name_repair = \"unique\", \n    num_threads = readr_threads(), progress = show_progress(), \n    show_col_types = should_show_types(), skip_empty_rows = TRUE, \n    lazy = should_read_lazy()) \nNULL\n\n# there's too many to list here, so we will just go over a few\n# run ?read_delim() to learn more\n# 1) delim - text delimiter.\n# default is NULL and read_delim() guesses delimiter\n#\n# 2) quote - symbol telling R when to quote a string\n# default is \"\\\"\"\n# below comes from R documentation on quotes\n# https://stat.ethz.ch/R-manual/R-devel/library/base/html/Quotes.html\n# identical() is a function that returns TRUE if two objects are equal\nidentical(1+4, 3+2)\n\n\n[1] TRUE\n\nidentical('\"It\\'s alive!\", he screamed.',\n          \"\\\"It's alive!\\\", he screamed.\") # same\n\n\n[1] TRUE\n\n#\n# 3) escape_backlash\n# use backlash to escape special characters?\n# default = FALSE\n#\n# 4) col_names\n# can be TRUE (default), meaning that R reads in the first row of values as column names\n# can FALSE - R creates column names (x1 x2 etc)\n# OR can be a character vector of custom column names\npoultry_custom_cols <- read_csv(\"../data_cleaned/poultry_tidy.csv\",\n                                col_names = c(\"prod\",\"yr\",\"mo\",\"$\"),\n                                skip = 1) # need this to skip the file's column names\npoultry_custom_cols\n\n\n# A tibble: 600 × 4\n   prod     yr mo          `$`\n   <chr> <dbl> <chr>     <dbl>\n 1 Whole  2013 January    2.38\n 2 Whole  2013 February   2.38\n 3 Whole  2013 March      2.38\n 4 Whole  2013 April      2.38\n 5 Whole  2013 May        2.38\n 6 Whole  2013 June       2.38\n 7 Whole  2013 July       2.38\n 8 Whole  2013 August     2.38\n 9 Whole  2013 September  2.38\n10 Whole  2013 October    2.38\n# … with 590 more rows\n\npoultry_custom_cols$`$` # note the backticks around the $ sign\n\n\n  [1] 2.38500 2.38500 2.38500 2.38500 2.38500 2.38500 2.38500 2.38500\n  [9] 2.38500 2.38500 2.38500 2.38500 7.03750 7.03750 7.03750 7.03750\n [17] 7.03750 7.03750 7.03750 7.03750 7.03750 7.03750 7.03750 7.03750\n [25] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n [33] 3.90500 3.90500 3.90500 3.90500 2.03500 2.03500 2.03500 2.03500\n [41] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n [49] 2.16250 2.16250 2.16250 2.16250 2.16250 2.16250 2.16250 2.16250\n [57] 2.16250 2.16250 2.16250 2.16250 2.35000 2.38500 2.38500 2.38500\n [65] 2.38500 2.38500 2.38500 2.38500 2.38500 2.38500 2.38500 2.38500\n [73] 6.37500 7.00000 7.00000 7.00000 7.00000 7.00000 7.00000 7.00000\n [81] 7.00000 7.00000 7.03750 7.03750 3.90500 3.90500 3.90500 3.90500\n [89] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n [97] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[105] 2.03500 2.03500 2.03500 2.03500 2.15000 2.15000 2.15000 2.15000\n[113] 2.15000 2.15000 2.15000 2.16250 2.16250 2.16250 2.16250 2.16250\n[121] 2.35000 2.35000 2.35000 2.35000 2.35000 2.35000 2.35000 2.35000\n[129] 2.35000 2.35000 2.35000 2.35000 6.37500 6.37500 6.37500 6.37500\n[137] 6.37500 6.37500 6.37500 6.37500 6.37500 6.37500 6.37500 6.37500\n[145] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[153] 3.90500 3.90500 3.90500 3.90500 2.03500 2.03500 2.03500 2.03500\n[161] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[169] 2.15000 2.15000 2.15000 2.15000 2.15000 2.15000 2.15000 2.15000\n[177] 2.15000 2.15000 2.15000 2.15000 2.48000 2.48000 2.48000 2.41500\n[185] 2.35000 2.35000 2.41500 2.35000 2.35000 2.35000 2.35000 2.35000\n[193] 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.42300\n[201] 6.37500 6.37500 6.37500 6.37500 3.90500 3.90500 3.90500 3.90500\n[209] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[217] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[225] 2.03500 2.03500 2.03500 2.03500 2.22000 2.22000 2.22000 2.22000\n[233] 2.22000 2.22000 2.22000 2.19200 2.15000 2.15000 2.15000 2.15000\n[241] 2.48000 2.48000 2.48000 2.48000 2.48000 2.48000 2.48000 2.48000\n[249] 2.48000 2.48000 2.48000 2.48000 6.45500 6.45500 6.45500 6.45500\n[257] 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500\n[265] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[273] 3.90500 3.90500 3.90500 3.90500 2.03500 2.03500 2.03500 2.03500\n[281] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[289] 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000\n[297] 2.22000 2.22000 2.22000 2.22000 2.20500 2.20500 2.20500 2.20500\n[305] 2.20500 2.48000 2.48000 2.48000 2.48000 2.48000 2.48000 2.48000\n[313] 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500\n[321] 6.45500 6.45500 6.45500 6.45500 3.90500 3.90500 3.90500 3.90500\n[329] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[337] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[345] 2.03500 2.03500 2.03500 2.03500 2.22000 2.22000 2.22000 2.22000\n[353] 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000\n[361] 2.20500 2.20500 2.20500 2.20500 2.20500 2.20500 2.20500 2.20500\n[369] 2.20500 2.20500 2.20500 2.20500 6.45500 6.45500 6.45500 6.45500\n[377] 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500\n[385] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[393] 3.90500 3.90500 3.90500 3.90500 2.03500 2.03500 2.03500 2.03500\n[401] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[409] 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000\n[417] 2.22000 2.22000 2.22000 2.22000 2.17000 2.17000 2.19625 2.20500\n[425] 2.20500 2.20500 2.20500 2.20500 2.20500 2.20500 2.20500 2.20500\n[433] 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500\n[441] 6.45500 6.45500 6.45500 6.45500 3.90500 3.90500 3.90500 3.90500\n[449] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[457] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[465] 2.03500 2.03500 2.03500 2.03500 2.22000 2.22000 2.22000 2.22000\n[473] 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000\n[481] 2.17000 2.17000 2.17000 2.17000 2.17000 2.17000 2.17000 2.17000\n[489] 2.17000 2.17000 2.17000 2.17000 6.44000 6.45500 6.45500 6.45500\n[497] 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500 6.45500\n[505] 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[513] 3.90500 3.90500 3.90500 3.90500 2.03500 2.03500 2.03500 2.03500\n[521] 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500 2.03500\n[529] 2.13000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000 2.22000\n[537] 2.22000 2.22000 2.22000 2.22000 1.97500 1.97500 2.09000 2.12000\n[545] 2.14500 2.16375 2.17000 2.17000 2.17000 2.17000 2.17000 2.17000\n[553] 6.45500 6.42500 6.42500 6.42500 6.42500 6.41000 6.42500 6.42500\n[561] 6.42500 6.42500 6.42500 6.42500      NA      NA      NA      NA\n[569]      NA      NA 3.90500 3.90500 3.90500 3.90500 3.90500 3.90500\n[577] 1.93500 1.93500 1.93500 1.93500 1.93500 2.01875 2.03500 2.03500\n[585] 2.03500 2.03500 2.03500 2.03500      NA 2.03000 2.03000 2.03000\n[593] 2.03000 2.00375 1.99500 1.99500 1.99500 1.99500 1.99500 1.99500\n\n# $ is a \"special symbol\" in R, because it is an operator used for indexing\n# $ is technically an illegal column name, but we can still use it with ``\n# same goes for column names consisting of numbers or other symbols, etc.\n#\n# 5) col_types\n# default=NULL\n# if NULL R guesses data type from first 1000 rows\n# can also specify manually (but be careful)\n# see ?read_delim and scroll to col_types for details\n#\n# 6) skip\n# number of lines to skip\n# default=0\n# can be very useful with messy data files\n#\n# 7) n_max\n# maximum number of lines to read\n# default=Inf\n#\n#\n\n\n\nRead in\n.xls/.xlsx files\n.xls and .xlsx are files created in\nMicrosoft Excel. There are separate functions read_xls()\nand read_xlsx(), but I find it’s best to use the wrapper\nfunction read_excel(). This will automatically call the\ncorrect function and avoid an error from accidentally mis-specifying the\nfile type.\nSee below for what happens if we call the wrong function for the file\ntype:\n\n\n# the try() function will try to run the code\n# see tryCatch() for more error handling \n# this code doesn't work because it tries to read the wrong file type\ntry(read_xls(\"../data_cleaned/poultry_tidy.xlsx\"))\n\n\nError : \n  filepath: /Users/seanconway/Teaching/DACSS_601_Su22/data_cleaned/poultry_tidy.xlsx\n  libxls error: Unable to open file\n\nThe code below works just fine, however:\n\n\n# this code works \npoultry_from_excel <- try(read_excel(\"poultry_tidy.xlsx\",\n                                     skip = 5,\n                                     col_names = c(\"prod\",\"year\",\"month\",\"price\"))) \n\n\nError : `path` does not exist: 'poultry_tidy.xlsx'\n\npoultry_from_excel \n\n\n[1] \"Error : `path` does not exist: 'poultry_tidy.xlsx'\\n\"\nattr(,\"class\")\n[1] \"try-error\"\nattr(,\"condition\")\n<simpleError: `path` does not exist: 'poultry_tidy.xlsx'>\n\nLet’s take a look at this tibble:\n\n\n# examining our tibble\nhead(poultry_from_excel) # view the first several rows\n\n\n[1] \"Error : `path` does not exist: 'poultry_tidy.xlsx'\\n\"\n\ncolnames(poultry_from_excel) # print column names\n\n\nNULL\n\ndplyr::glimpse(poultry_from_excel) # tidy little summary of it\n\n\n 'try-error' chr \"Error : `path` does not exist: 'poultry_tidy.xlsx'\\n\"\n - attr(*, \"condition\")=List of 2\n  ..$ message: chr \"`path` does not exist: 'poultry_tidy.xlsx'\"\n  ..$ call   : NULL\n  ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n# the package::function() syntax is only necessary if the package isn't loaded\n\n\n\nFunction documentation:\n\n\n# to view function documentation\n?read_excel\n\n# optional arguments\n# 1) sheet=NULL\n# number of the sheet to read in\n# by default it reads the first sheet\n\n# 2) range=NULL\n# range of cells to read in\n# uses the cellranger package to work with specific cells in Excel files\n# for more, see the cellranger package\n# https://cran.r-project.org/web/packages/cellranger/index.html\n\n# 3) col_names=TRUE\n# how to get column names (works the same as read_delim())\n\n# 4) col_types=NULL\n# types of data in columns (works the same as read_delim())\n\n# 5) skip = 0\n# number of lines to skip (works the same as read_delim())\n\n# 6) n_max=Inf\n# max lines to read (works the same as read_delim())\n\n\n\nReading in .RData\nFiles\nReading .RData is less commonly needed, but it’s still important to\nknow about. .RData is a file type exclusively associated\nwith R. It’s commonly used when someone has performed operations with\ndata and saved the results to give to collaborators.\nWe can use the load() function to load R\nobjects into our R environment from a file:\n\n\n# running the load() function on the data file name will load the objects into your R environment\nload(\"../data_cleaned/poultry_tidy.RData\")\npoultry_tidy\n\n\n# A tibble: 600 × 4\n   Product  Year Month     Price_Dollar\n   <chr>   <int> <chr>            <dbl>\n 1 Whole    2013 January           2.38\n 2 Whole    2013 February          2.38\n 3 Whole    2013 March             2.38\n 4 Whole    2013 April             2.38\n 5 Whole    2013 May               2.38\n 6 Whole    2013 June              2.38\n 7 Whole    2013 July              2.38\n 8 Whole    2013 August            2.38\n 9 Whole    2013 September         2.38\n10 Whole    2013 October           2.38\n# … with 590 more rows\n\n# there's now a poultry_tidy object in our R environment\n\n\n\nNote that we do not assign the data file to an\nobject. Rather, it comes in as an object based on whatever the previous\nuser named it as. If we try to assign it as an object, the object will\nonly have the name of the data file, rather than the\ndata itself:\n\n\n# note that this operation shouldn't include any variable assignment\ntest_dat <- load(\"../data_cleaned/poultry_tidy.RData\")\ntest_dat # now it contains the object name, not the object itself\n\n\n[1] \"poultry_tidy\"\n\nYou can also save any number of R objects to a\n.RData file using the save() function:\n\n\na <- rnorm(1000)\nb <- matrix(runif(100),nrow=50,ncol=2)\nc <- as_tibble(mtcars)\nsave(a,b,c,file=\"test_objs.RData\")\n# there is now a test_objs.RData file in my working directory: \nlist.files()\n\n\n[1] \"data_import.html\"             \"data_import.Rmd\"             \n[3] \"more_data_import_-dplyr.html\" \"more_data_import_&dplyr.Rmd\" \n[5] \"Rmd_Demo.html\"                \"Rmd_Demo.Rmd\"                \n[7] \"rsconnect\"                    \"test_objs.RData\"             \n\nLet’s remove these objects from our R environment and\nre-load them from the file we saved:\n\n\n# remove objects from environment\nrm(list=c(\"a\",\"b\",\"c\"))\n\n# now they're back! (If you save them)\ntry(load(\"test_objs.RData\"))\n\n\n\nConclusion\nYou now know a little bit about how to read in some common data\ntypes. Note that these aren’t the only types of data\nyou’ll encounter, but they are by far the most common ones.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-07T20:45:21-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscomspconway911852/",
    "title": "More data import/dplyr",
    "description": "More data import and an introduction to the dplyr package.",
    "author": [
      {
        "name": "Sean Conway",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\nIntroduction\nToday, we’ll be working on how to import a slightly more difficult\ndataset. Specifically, we’ll be looking at a dataset on the cost of\nfoodborne illnesses in the US. These data were obtained from\ndata.gov.\nThe data\nLet’s take a look at these data.\n\nAs you can see, these data come from an Excel file and are not\noptimized to easily read into R. Luckily, we can use the\nreadxl package to get them into R (albeit with\na little work).\n\n\nlibrary(readxl)\n\n\n\nReading in the data\nThe first thing we’ll notice is that we need to skip a few rows.\nSpecifically, we need to skip the first 5 rows, as they aren’t needed.\nWe can specify skip=5 when we read in the data.\n\n\nd <- read_excel(\"../data/Total_cost_for_top_15_pathogens_2018.xlsx\",\n                skip=5)\nd\n\n\n# A tibble: 22 × 3\n   `Campylobacter spp. (all species)`        `845024` `2181485783.43…`\n   <chr>                                        <dbl>            <dbl>\n 1 Clostridium perfringens                     965958       384277856.\n 2 Cryptosporidium spp. (all species)           57616        58394152.\n 3 Cyclospora cayetanensis                      11407         2571518.\n 4 Listeria monocytogenes                        1591      3189686110.\n 5 Norovirus                                  5461731      2566984191.\n 6 Salmonella (non-typhoidal species)         1027561      4142179161.\n 7 Shigella (all species)                      131254       159202402.\n 8 Shiga toxin-producing Escherichia coli O…    63153       311036907.\n 9 non-O157 Shiga toxin-producing Escherich…   112752        31701852.\n10 Toxoplasma gondii                            86686      3744008907.\n# … with 12 more rows\n\nThere a couple things wrong here. First, the column names are wrong.\nSince we skipped the column names, R tried naming the\ncolumns based on the first row of data (which is wrong!). We can specify\nthe column names ourselves, using the col_names argument.\nWe can give col_names a character vector\nthat contains the names we want to give our columns. Specifically, we\ncan specify c(\"pathogen\",\"cases\",\"cost\") as the names of\nour columns. Note that pathogen wasn’t specified in the\noriginal data file, but we’re specifying it here.\nNext, you’ll notice that the data go on longer than we need. There’s\nsome white space in the data file, as well as a row containing the total\ncost for all pathogens (which we can eliminate). There’s also a couple\nof notes that we can eliminate. Rather than specify skip,\nwe can instead use the range argument to specify the\nrange of cells we want to read in. Looking back at our\ndata file, it looks like we only need cells A6:C20.\n\nLet’s try this again! As a reminder, we will be using the\ncol_names argument to name the columns of our data and the\nrange argument to specify the cells we want R\nto read in. Also note that we specify the path argument\nexplicitly now. read_excel() by default assumes the first\nthing you give it is the file path, but it doesn’t hurt to be\nexplicit.\n\n\ndataset <- read_excel(path=\"../data/Total_cost_for_top_15_pathogens_2018.xlsx\",\n                      range=\"A6:C20\",\n                      col_names=c(\"pathogen\",\"cases\",\"cost\"))\ndataset\n\n\n# A tibble: 15 × 3\n   pathogen                                               cases   cost\n   <chr>                                                  <dbl>  <dbl>\n 1 Campylobacter spp. (all species)                      8.45e5 2.18e9\n 2 Clostridium perfringens                               9.66e5 3.84e8\n 3 Cryptosporidium spp. (all species)                    5.76e4 5.84e7\n 4 Cyclospora cayetanensis                               1.14e4 2.57e6\n 5 Listeria monocytogenes                                1.59e3 3.19e9\n 6 Norovirus                                             5.46e6 2.57e9\n 7 Salmonella (non-typhoidal species)                    1.03e6 4.14e9\n 8 Shigella (all species)                                1.31e5 1.59e8\n 9 Shiga toxin-producing Escherichia coli O157 (STEC O1… 6.32e4 3.11e8\n10 non-O157 Shiga toxin-producing Escherichia coli (STE… 1.13e5 3.17e7\n11 Toxoplasma gondii                                     8.67e4 3.74e9\n12 Vibrio parahaemolyticus                               3.47e4 4.57e7\n13 Vibrio vulnificus                                     9.6 e1 3.59e8\n14 Vibrio non-cholera species other than V. parahaemoly… 1.76e4 8.17e7\n15 Yersinia enterocolitica                               9.77e4 3.13e8\n\nVoila! The dataset looks great.\nA little bit about dplyr\ndplyr is an R package for manipulating,\nwrangling, and transforming data. We will touch on it more next week,\nbut this is a brief introduction to a few useful dplyr\nfunctions.\n\n\nlibrary(dplyr)\n\n\n\nselect()\nselect() allows us to only pick out\ncertain columns from a dataframe.\nBelow, we extract the cases column from our\ndataset object (see above). We don’t have to specify it in\nquotes (the reasons for this are beyond the scope of this lesson).\n\n\nselect(dataset, cases)\n\n\n# A tibble: 15 × 1\n     cases\n     <dbl>\n 1  845024\n 2  965958\n 3   57616\n 4   11407\n 5    1591\n 6 5461731\n 7 1027561\n 8  131254\n 9   63153\n10  112752\n11   86686\n12   34664\n13      96\n14   17564\n15   97656\n\nThe first argument tells R the dataframe we are looking\nin (dataset), and the second argument tells R\nthe columns we want to pick out.\nWe can also select multiple columns.\n\n\nselect(dataset, cases, cost)\n\n\n# A tibble: 15 × 2\n     cases        cost\n     <dbl>       <dbl>\n 1  845024 2181485783.\n 2  965958  384277856.\n 3   57616   58394152.\n 4   11407    2571518.\n 5    1591 3189686110.\n 6 5461731 2566984191.\n 7 1027561 4142179161.\n 8  131254  159202402.\n 9   63153  311036907.\n10  112752   31701852.\n11   86686 3744008907.\n12   34664   45735332.\n13      96  359481557.\n14   17564   81749064.\n15   97656  313297920.\n\nYou can even use the - operator to tell R\nto not select certain columns. This is particularly\nhelpful when you have a dataset with many columns, but you want to\nremove a couple of them. Rather than say, write out the names of 28\ncolumns you want to include, you can simply write the\nnames of the 2 columns you don’t want to include.\n\n\nselect(dataset, -pathogen)\n\n\n# A tibble: 15 × 2\n     cases        cost\n     <dbl>       <dbl>\n 1  845024 2181485783.\n 2  965958  384277856.\n 3   57616   58394152.\n 4   11407    2571518.\n 5    1591 3189686110.\n 6 5461731 2566984191.\n 7 1027561 4142179161.\n 8  131254  159202402.\n 9   63153  311036907.\n10  112752   31701852.\n11   86686 3744008907.\n12   34664   45735332.\n13      96  359481557.\n14   17564   81749064.\n15   97656  313297920.\n\nfilter()\nThe filter() function allows us to only include rows of\nthe data that meet certain criteria. For example, imagine that we only\nwant to analyze pathogens that infected at least 10,000 people. We can\nuse filter() to tell R to only include rows of\nthe data where cases is greater than or equal to\n10,000.\n\n\nfilter(dataset, cases>=10000)\n\n\n# A tibble: 13 × 3\n   pathogen                                               cases   cost\n   <chr>                                                  <dbl>  <dbl>\n 1 Campylobacter spp. (all species)                      8.45e5 2.18e9\n 2 Clostridium perfringens                               9.66e5 3.84e8\n 3 Cryptosporidium spp. (all species)                    5.76e4 5.84e7\n 4 Cyclospora cayetanensis                               1.14e4 2.57e6\n 5 Norovirus                                             5.46e6 2.57e9\n 6 Salmonella (non-typhoidal species)                    1.03e6 4.14e9\n 7 Shigella (all species)                                1.31e5 1.59e8\n 8 Shiga toxin-producing Escherichia coli O157 (STEC O1… 6.32e4 3.11e8\n 9 non-O157 Shiga toxin-producing Escherichia coli (STE… 1.13e5 3.17e7\n10 Toxoplasma gondii                                     8.67e4 3.74e9\n11 Vibrio parahaemolyticus                               3.47e4 4.57e7\n12 Vibrio non-cholera species other than V. parahaemoly… 1.76e4 8.17e7\n13 Yersinia enterocolitica                               9.77e4 3.13e8\n\nThe first argument tells R the dataframe we want to look\nin, while the second argument tells R the criteria for\nincluding a row. Specifically, a row in dataset should\nonly be included if its value on the variable\ncases is greater than or equal to 10000.\nWe can also use the & (and) operator to include\nmultiple criteria. For example, say we want to filter\nout the rows of data for pathogens that don’t have at least 10,000 cases\nand costed less than $10,000,000 to the US in 2018.\n\n\nfilter(dataset, cases>=10000 & cost>=10000000)\n\n\n# A tibble: 12 × 3\n   pathogen                                               cases   cost\n   <chr>                                                  <dbl>  <dbl>\n 1 Campylobacter spp. (all species)                      8.45e5 2.18e9\n 2 Clostridium perfringens                               9.66e5 3.84e8\n 3 Cryptosporidium spp. (all species)                    5.76e4 5.84e7\n 4 Norovirus                                             5.46e6 2.57e9\n 5 Salmonella (non-typhoidal species)                    1.03e6 4.14e9\n 6 Shigella (all species)                                1.31e5 1.59e8\n 7 Shiga toxin-producing Escherichia coli O157 (STEC O1… 6.32e4 3.11e8\n 8 non-O157 Shiga toxin-producing Escherichia coli (STE… 1.13e5 3.17e7\n 9 Toxoplasma gondii                                     8.67e4 3.74e9\n10 Vibrio parahaemolyticus                               3.47e4 4.57e7\n11 Vibrio non-cholera species other than V. parahaemoly… 1.76e4 8.17e7\n12 Yersinia enterocolitica                               9.77e4 3.13e8\n\nWe might also be interested in pathogens that had a high case count\nOR a high economic cost. For this, we can use the\nlogical or (|) operator to consider pathogens with at least\n10,000 cases OR at least $10,000,000 in cost to the\nUS.\n\n\nfilter(dataset, cases>=1000 | cost>=10000000)\n\n\n# A tibble: 15 × 3\n   pathogen                                               cases   cost\n   <chr>                                                  <dbl>  <dbl>\n 1 Campylobacter spp. (all species)                      8.45e5 2.18e9\n 2 Clostridium perfringens                               9.66e5 3.84e8\n 3 Cryptosporidium spp. (all species)                    5.76e4 5.84e7\n 4 Cyclospora cayetanensis                               1.14e4 2.57e6\n 5 Listeria monocytogenes                                1.59e3 3.19e9\n 6 Norovirus                                             5.46e6 2.57e9\n 7 Salmonella (non-typhoidal species)                    1.03e6 4.14e9\n 8 Shigella (all species)                                1.31e5 1.59e8\n 9 Shiga toxin-producing Escherichia coli O157 (STEC O1… 6.32e4 3.11e8\n10 non-O157 Shiga toxin-producing Escherichia coli (STE… 1.13e5 3.17e7\n11 Toxoplasma gondii                                     8.67e4 3.74e9\n12 Vibrio parahaemolyticus                               3.47e4 4.57e7\n13 Vibrio vulnificus                                     9.6 e1 3.59e8\n14 Vibrio non-cholera species other than V. parahaemoly… 1.76e4 8.17e7\n15 Yersinia enterocolitica                               9.77e4 3.13e8\n\nWrapping up\nThere’s many types of complicated datasets that you’ll encounter in\nyour data analysis career. This has been a short introduction to these\ntypes of tricky datasets and some useful dplyr functions\nfor working with them.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-07T20:45:17-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscomhammlyssdshomework01/",
    "title": "Homework 1",
    "description": "This is my submission for Homework 1",
    "author": [
      {
        "name": "Alyssa Hammond",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\r\n#My Code\r\n\r\n\r\n7*7 # multiplication\r\n\r\n\r\n[1] 49\r\n\r\n7*7 == 49 #boolean \r\n\r\n\r\n[1] TRUE\r\n\r\none <- c(13,14,15) #define a vector\r\none * 2 #math on the vector and display\r\n\r\n\r\n[1] 26 28 30\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-07T20:55:16-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscomdoctorchill08910305/",
    "title": "Homework 1",
    "description": "DACSS 601 -- Submission 1",
    "author": [
      {
        "name": "Caleb Hill",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\r\nMy Code\r\nAfter uninstalling RStudio, re-installing, and then re-installing the\r\nknitr package, today we’re going to complete some basic arithmetic:\r\n\r\n\r\n#first, create a list of vectors\r\ndata <- c(1,3,5,7,9)\r\n\r\n#second, let's try adding them together\r\ndata + data\r\n\r\n\r\n[1]  2  6 10 14 18\r\n\r\n#third, let's attempt some multiplication\r\ndata * data\r\n\r\n\r\n[1]  1  9 25 49 81\r\n\r\n#finally, let's finish our lesson with some division\r\ndata / data\r\n\r\n\r\n[1] 1 1 1 1 1\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-07T20:56:39-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscommacuriel910884/",
    "title": "DACSS601 HW1",
    "description": "My first markdown file published to RPubs",
    "author": [
      {
        "name": "Miguel Curiel",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\nMy Code\n\n\n2 + 2\n\n\n[1] 4\n\nEt Voila!\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-07T20:57:41-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscomhongbingt910911/",
    "title": "HW1_Tang",
    "description": "R Markdown",
    "author": [
      {
        "name": "Hongbing",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\r\nMy Code\r\n\r\n\r\nscores <- c(90,95,99,94,92,85,89,100,88,96)\r\nscores\r\n\r\n\r\n [1]  90  95  99  94  92  85  89 100  88  96\r\n\r\ngrade <-scores + 5\r\ngrade\r\n\r\n\r\n [1]  95 100 104  99  97  90  94 105  93 101\r\n\r\nMy Answer!\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-06-07T20:58:38-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscomkathypaz911005/",
    "title": "DACSS HW 1",
    "description": "Testing RMarkdown",
    "author": [
      {
        "name": "Katherine Barahona Paz",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\nMy Code\n\n\ntemperatures <- c(78, 81, 92, 67, 79, 85, 83)\ntemperatures\n\n\n[1] 78 81 92 67 79 85 83\n\navg_temp <- mean(temperatures)\navg_temp \n\n\n[1] 80.71429\n\nAverage temperature for this week!\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-07T21:01:02-04:00",
    "input_file": {}
  },
  {
    "path": "posts/httpsrpubscomspconway911968/",
    "title": "DACSS601 HW1-RMD-FB",
    "description": "",
    "author": [
      {
        "name": "Felix Betancourt",
        "url": {}
      }
    ],
    "date": "2022-06-07",
    "categories": [],
    "contents": "\nMy Code\nThis is my first RMD.\n\n\n# Example of a simple calculation\n2+2\n\n\n[1] 4\n\nAnother code example\nNow let’s try another chunk\n\n\n#create variable z\nz <- 9\n#create variable y\ny <- 18\n#see it in action\nz * y\n\n\n[1] 162\n\nAnd it is ready to share!\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-07T21:14:53-04:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to DACSS 601",
    "description": "Welcome to DACSS 601: Foundations of Data Science - Summer Session 2022, Section 02. This is the course blog, where all student posts will live.",
    "author": [
      {
        "name": "Sean Conway",
        "url": {}
      }
    ],
    "date": "2022-05-28",
    "categories": [
      "welcome"
    ],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2022-06-07T21:15:01-04:00",
    "input_file": "welcome.knit.md"
  },
  {
    "path": "posts/httpsrpubscomspconway849705/",
    "title": "Test Post Round 2",
    "description": "A new article created using the Distill format.",
    "author": [
      {
        "name": "Sean Conway",
        "url": {}
      }
    ],
    "date": "2022-05-28",
    "categories": [],
    "contents": "\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndata(storms)\nggplot(storms, aes(wind,pressure))+\n  geom_point(alpha=.5,col=\"blue\")+\n  geom_abline(slope=1,intercept=0)+\n  facet_wrap(vars(status))\n\n\n\n\n\n\n\n",
    "preview": "posts/httpsrpubscomspconway849705/distill-preview.png",
    "last_modified": "2022-05-28T10:12:54-04:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
